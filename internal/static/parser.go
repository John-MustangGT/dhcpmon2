// ===== internal/static/parser.go =====
package static

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"strings"
	"unicode"
	
	"dhcpmon/pkg/models"
)

// Parser handles parsing of dnsmasq static configuration files
type Parser struct{}

// NewParser creates a new static configuration parser
func NewParser() *Parser {
	return &Parser{}
}

// ParseFile parses a dnsmasq static configuration file
func (p *Parser) ParseFile(filename string) ([]models.StaticDHCPEntry, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to open file %s: %w", filename, err)
	}
	defer file.Close()

	var entries []models.StaticDHCPEntry
	scanner := bufio.NewScanner(file)
	lineNumber := 0

	for scanner.Scan() {
		lineNumber++
		line := scanner.Text()
		
		entry, err := p.parseLine(line, lineNumber)
		if err != nil {
			// Skip invalid lines but log them
			continue
		}
		
		if entry != nil {
			entries = append(entries, *entry)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading file: %w", err)
	}

	return entries, nil
}

// parseLine parses a single line from the configuration file
func (p *Parser) parseLine(line string, lineNumber int) (*models.StaticDHCPEntry, error) {
	originalLine := line
	line = strings.TrimSpace(line)
	
	// Skip empty lines
	if line == "" {
		return nil, nil
	}
	
	// Check if line is commented out
	enabled := true
	comment := ""
	
	if strings.HasPrefix(line, "#") {
		enabled = false
		line = strings.TrimSpace(line[1:])
		
		// Extract inline comment if it exists after dhcp-host
		if strings.Contains(line, "#") && strings.Contains(line, "dhcp-host=") {
			parts := strings.SplitN(line, "#", 2)
			line = strings.TrimSpace(parts[0])
			if len(parts) > 1 {
				comment = strings.TrimSpace(parts[1])
			}
		}
	} else {
		// Extract inline comment
		if strings.Contains(line, "#") {
			parts := strings.SplitN(line, "#", 2)
			line = strings.TrimSpace(parts[0])
			if len(parts) > 1 {
				comment = strings.TrimSpace(parts[1])
			}
		}
	}
	
	// Check if this is a dhcp-host line
	if !strings.HasPrefix(line, "dhcp-host=") {
		return nil, nil
	}
	
	// Parse dhcp-host parameters
	paramStr := strings.TrimPrefix(line, "dhcp-host=")
	params := strings.Split(paramStr, ",")
	
	if len(params) == 0 {
		return nil, fmt.Errorf("empty dhcp-host line")
	}
	
	entry := &models.StaticDHCPEntry{
		ID:         fmt.Sprintf("line_%d", lineNumber),
		Comment:    comment,
		Enabled:    enabled,
		LineNumber: lineNumber,
		RawLine:    originalLine,
	}
	
	// Parse parameters
	for i, param := range params {
		param = strings.TrimSpace(param)
		
		if param == "" {
			continue
		}
		
		// Check for tag assignment (set:tagname or tag:tagname)
		if strings.HasPrefix(param, "set:") || strings.HasPrefix(param, "tag:") {
			entry.Tag = param[4:]
			continue
		}
		
		// Try to parse as MAC address
		if mac, err := net.ParseMAC(param); err == nil {
			entry.MAC = mac
			continue
		}
		
		// Try to parse as IP address
		if ip := net.ParseIP(param); ip != nil {
			entry.IP = ip
			continue
		}
		
		// Check if it looks like a lease time (ends with time units)
		if p.isLeaseTime(param) {
			entry.LeaseTime = param
			continue
		}
		
		// Otherwise, treat as hostname
		if entry.Hostname == "" {
			entry.Hostname = param
		}
	}
	
	return entry, nil
}

// isLeaseTime checks if a parameter looks like a lease time specification
func (p *Parser) isLeaseTime(param string) bool {
	param = strings.ToLower(param)
	suffixes := []string{"s", "m", "h", "d", "w", "infinite"}
	
	for _, suffix := range suffixes {
		if strings.HasSuffix(param, suffix) {
			return true
		}
	}
	
	return false
}

// WriteFile writes static DHCP entries back to a configuration file
func (p *Parser) WriteFile(filename string, entries []models.StaticDHCPEntry) error {
	// Create backup
	backupFile := filename + ".backup"
	if err := p.copyFile(filename, backupFile); err != nil {
		return fmt.Errorf("failed to create backup: %w", err)
	}
	
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filename, err)
	}
	defer file.Close()
	
	// Write header comment
	fmt.Fprintln(file, "# Static DHCP reservations")
	fmt.Fprintln(file, "# Generated by DHCP Monitor")
	fmt.Fprintln(file, "# Format: dhcp-host=MAC,IP,hostname[,lease-time]")
	fmt.Fprintln(file, "")
	
	// Write entries
	for _, entry := range entries {
		line := entry.ToDnsmasqLine()
		fmt.Fprintln(file, line)
	}
	
	return nil
}

// copyFile creates a backup copy of a file
func (p *Parser) copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()
	
	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()
	
	_, err = io.Copy(destFile, sourceFile)
	return err
}

